{"ast":null,"code":"export default class TokenUtil {\n  // localStorage에서 토큰을 가져옴 (기본 키: 'accessToken')\n  static getToken(key = 'accessToken') {\n    return localStorage.getItem(key) || null;\n  }\n\n  // Base64 URL -> Base64 변환\n  static base64UrlToBase64(base64Url) {\n    return base64Url.replace(/-/g, '+').replace(/_/g, '/');\n  }\n\n  // UTF-8 디코딩을 고려한 JWT 디코딩 함수\n  static decodeToken(token) {\n    try {\n      const payloadBase64Url = token.split('.')[1];\n      const payloadBase64 = this.base64UrlToBase64(payloadBase64Url);\n      const decodedStr = atob(payloadBase64); // Base64 디코딩\n      const utf8DecodedStr = decodeURIComponent(escape(decodedStr)); // UTF-8 디코딩\n      return JSON.parse(utf8DecodedStr);\n    } catch (error) {\n      console.error(\"토큰 디코딩 실패:\", error);\n      return null;\n    }\n  }\n\n  // 토큰의 만료 여부를 체크 (만료 시간(exp) 필드를 사용)\n  // ** 토큰이 expired라면?, 로그인의 연계로 refresh토큰을 통해서 재발급을 하고 그럼에도 문제가 발생한다면, 다시 로그인을 하는것이 맞을꺼 같다.\n  // 해당 재발급 시점을 잘 생각해보자.\n  // 토큰에서 확인을 한다면? 이후의 행동때 또 expired가 발생할 수 있으니까. 잘 생각해보자.\n  static isTokenExpired(token) {\n    const decoded = this.decodeToken(token);\n    if (!decoded || !decoded.exp) return true;\n    const now = Date.now() / 1000;\n    return decoded.exp < now;\n  }\n\n  // 토큰에서 사용자 정보를 추출하여 반환 (예: userId, roles, nickname)\n  static getUserInfo(token) {\n    const decoded = this.decodeToken(token);\n    if (!decoded) return null;\n    // JWT payload의 필드 이름은 상황에 따라 다를 수 있으니, 실제 토큰 구조에 맞게 수정 필요\n    const userId = decoded.sub || decoded.userId;\n    const roles = decoded.roles;\n    const nickname = decoded.nickname;\n    const profileImagePath = decoded.profileImagePath;\n    return {\n      userId,\n      roles,\n      nickname,\n      profileImagePath\n    };\n  }\n\n  // 토큰의 유효성을 검사 (토큰 존재 여부 및 만료 여부 체크)\n  static validateToken(key = 'accessToken') {\n    const token = this.getToken(key);\n    if (!token) return {\n      valid: false,\n      reason: \"No token found\"\n    };\n    if (this.isTokenExpired(token)) return {\n      valid: false,\n      reason: \"Token expired\"\n    };\n    return {\n      valid: true,\n      reason: \"Token is valid\"\n    };\n  }\n}","map":{"version":3,"names":["TokenUtil","getToken","key","localStorage","getItem","base64UrlToBase64","base64Url","replace","decodeToken","token","payloadBase64Url","split","payloadBase64","decodedStr","atob","utf8DecodedStr","decodeURIComponent","escape","JSON","parse","error","console","isTokenExpired","decoded","exp","now","Date","getUserInfo","userId","sub","roles","nickname","profileImagePath","validateToken","valid","reason"],"sources":["/Users/kyoung/soundbrew-react/src/utils/token/tokenUtil.js"],"sourcesContent":["export default class TokenUtil {\n    // localStorage에서 토큰을 가져옴 (기본 키: 'accessToken')\n    static getToken(key = 'accessToken') {\n        return localStorage.getItem(key) || null;\n    }\n\n   // Base64 URL -> Base64 변환\n    static base64UrlToBase64(base64Url) {\n        return base64Url.replace(/-/g, '+').replace(/_/g, '/');\n    }\n\n    // UTF-8 디코딩을 고려한 JWT 디코딩 함수\n    static decodeToken(token) {\n        try {\n            const payloadBase64Url = token.split('.')[1];\n            const payloadBase64 = this.base64UrlToBase64(payloadBase64Url);\n            const decodedStr = atob(payloadBase64); // Base64 디코딩\n            const utf8DecodedStr = decodeURIComponent(escape(decodedStr)); // UTF-8 디코딩\n            return JSON.parse(utf8DecodedStr);\n        } catch (error) {\n            console.error(\"토큰 디코딩 실패:\", error);\n            return null;\n        }\n    }\n\n    // 토큰의 만료 여부를 체크 (만료 시간(exp) 필드를 사용)\n    // ** 토큰이 expired라면?, 로그인의 연계로 refresh토큰을 통해서 재발급을 하고 그럼에도 문제가 발생한다면, 다시 로그인을 하는것이 맞을꺼 같다.\n    // 해당 재발급 시점을 잘 생각해보자.\n    // 토큰에서 확인을 한다면? 이후의 행동때 또 expired가 발생할 수 있으니까. 잘 생각해보자.\n    static isTokenExpired(token) {\n        const decoded = this.decodeToken(token);\n        if (!decoded || !decoded.exp) return true;\n        const now = Date.now() / 1000;\n        return decoded.exp < now;\n    }\n\n    // 토큰에서 사용자 정보를 추출하여 반환 (예: userId, roles, nickname)\n    static getUserInfo(token) {\n        const decoded = this.decodeToken(token);\n        if (!decoded) return null;\n        // JWT payload의 필드 이름은 상황에 따라 다를 수 있으니, 실제 토큰 구조에 맞게 수정 필요\n        const userId = decoded.sub || decoded.userId;\n        const roles = decoded.roles;\n        const nickname = decoded.nickname;\n        const profileImagePath = decoded.profileImagePath\n        return { userId, roles, nickname, profileImagePath };\n    }\n\n    // 토큰의 유효성을 검사 (토큰 존재 여부 및 만료 여부 체크)\n    static validateToken(key = 'accessToken') {\n        const token = this.getToken(key);\n        if (!token) return { valid: false, reason: \"No token found\" };\n        if (this.isTokenExpired(token)) return { valid: false, reason: \"Token expired\" };\n        return { valid: true, reason: \"Token is valid\" };\n    }\n}\n"],"mappings":"AAAA,eAAe,MAAMA,SAAS,CAAC;EAC3B;EACA,OAAOC,QAAQA,CAACC,GAAG,GAAG,aAAa,EAAE;IACjC,OAAOC,YAAY,CAACC,OAAO,CAACF,GAAG,CAAC,IAAI,IAAI;EAC5C;;EAED;EACC,OAAOG,iBAAiBA,CAACC,SAAS,EAAE;IAChC,OAAOA,SAAS,CAACC,OAAO,CAAC,IAAI,EAAE,GAAG,CAAC,CAACA,OAAO,CAAC,IAAI,EAAE,GAAG,CAAC;EAC1D;;EAEA;EACA,OAAOC,WAAWA,CAACC,KAAK,EAAE;IACtB,IAAI;MACA,MAAMC,gBAAgB,GAAGD,KAAK,CAACE,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;MAC5C,MAAMC,aAAa,GAAG,IAAI,CAACP,iBAAiB,CAACK,gBAAgB,CAAC;MAC9D,MAAMG,UAAU,GAAGC,IAAI,CAACF,aAAa,CAAC,CAAC,CAAC;MACxC,MAAMG,cAAc,GAAGC,kBAAkB,CAACC,MAAM,CAACJ,UAAU,CAAC,CAAC,CAAC,CAAC;MAC/D,OAAOK,IAAI,CAACC,KAAK,CAACJ,cAAc,CAAC;IACrC,CAAC,CAAC,OAAOK,KAAK,EAAE;MACZC,OAAO,CAACD,KAAK,CAAC,YAAY,EAAEA,KAAK,CAAC;MAClC,OAAO,IAAI;IACf;EACJ;;EAEA;EACA;EACA;EACA;EACA,OAAOE,cAAcA,CAACb,KAAK,EAAE;IACzB,MAAMc,OAAO,GAAG,IAAI,CAACf,WAAW,CAACC,KAAK,CAAC;IACvC,IAAI,CAACc,OAAO,IAAI,CAACA,OAAO,CAACC,GAAG,EAAE,OAAO,IAAI;IACzC,MAAMC,GAAG,GAAGC,IAAI,CAACD,GAAG,CAAC,CAAC,GAAG,IAAI;IAC7B,OAAOF,OAAO,CAACC,GAAG,GAAGC,GAAG;EAC5B;;EAEA;EACA,OAAOE,WAAWA,CAAClB,KAAK,EAAE;IACtB,MAAMc,OAAO,GAAG,IAAI,CAACf,WAAW,CAACC,KAAK,CAAC;IACvC,IAAI,CAACc,OAAO,EAAE,OAAO,IAAI;IACzB;IACA,MAAMK,MAAM,GAAGL,OAAO,CAACM,GAAG,IAAIN,OAAO,CAACK,MAAM;IAC5C,MAAME,KAAK,GAAGP,OAAO,CAACO,KAAK;IAC3B,MAAMC,QAAQ,GAAGR,OAAO,CAACQ,QAAQ;IACjC,MAAMC,gBAAgB,GAAGT,OAAO,CAACS,gBAAgB;IACjD,OAAO;MAAEJ,MAAM;MAAEE,KAAK;MAAEC,QAAQ;MAAEC;IAAiB,CAAC;EACxD;;EAEA;EACA,OAAOC,aAAaA,CAAC/B,GAAG,GAAG,aAAa,EAAE;IACtC,MAAMO,KAAK,GAAG,IAAI,CAACR,QAAQ,CAACC,GAAG,CAAC;IAChC,IAAI,CAACO,KAAK,EAAE,OAAO;MAAEyB,KAAK,EAAE,KAAK;MAAEC,MAAM,EAAE;IAAiB,CAAC;IAC7D,IAAI,IAAI,CAACb,cAAc,CAACb,KAAK,CAAC,EAAE,OAAO;MAAEyB,KAAK,EAAE,KAAK;MAAEC,MAAM,EAAE;IAAgB,CAAC;IAChF,OAAO;MAAED,KAAK,EAAE,IAAI;MAAEC,MAAM,EAAE;IAAiB,CAAC;EACpD;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}